// ============================================
// KIRANA BILLING PLATFORM - DATA MANAGER
// Handles encryption, storage, and real-time sync
// ============================================

class DataManager {
    constructor() {
        this.encryptionKey = 'KIRANA_SECURE_2026';
        this.syncInterval = 1500; // 1.5 seconds
        this.listeners = [];
        this.initializeStorage();
        this.startSync();
        this.imageCache = {}; // Cache to avoid redundant API calls
    }

    // ============================================
    // SMART IMAGE ENGINE (Automatic Market Imagery)
    // ============================================

    async fetchProductImage(name, brand, category) {
        if (!name && !brand) return null;
        const b = (brand && brand !== "N/A" && brand !== "null") ? brand.trim() : "";
        const n = (name || "").trim();
        const cat = (category || "").trim();
        const cacheKey = `${b}_${n}_${cat}`.toLowerCase();
        if (this.imageCache[cacheKey]) return this.imageCache[cacheKey];

        // --- THE TENSOR-EYE QUAD-VORTEX SEARCH ENGINE ---
        // 1. STRATEGY A: LIVE RETAIL SCRAPER (Bing/Retail Intelligence)
        const searchVariations = [
            `${b} ${n} product packaging real image`,
            `${b} ${n} amazon india photo`,
            `${b} ${n} jiomart grocery`,
            `${n} product box shot`
        ];

        for (const queryTerm of searchVariations) {
            try {
                const query = encodeURIComponent(queryTerm).replace(/%20/g, '+');
                const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(`https://www.bing.com/images/search?q=${query}&first=1`)}`;
                const response = await fetch(proxyUrl);
                const data = await response.json();
                const html = data.contents;

                const murlRegex = /murl&quot;:&quot;(https?:\/\/.*?)&quot;/g;
                const matches = [...html.matchAll(murlRegex)];

                if (matches && matches.length > 0) {
                    for (let i = 0; i < Math.min(matches.length, 10); i++) {
                        const imgUrl = matches[i][1];

                        // RELEVANCE SCORING: 
                        // High confidence for grocery/retail domains
                        const isCommercial = /amazon|flipkart|jiomart|bigbasket|blinkit|zepto|nykaa|1mg|itc|unilever|dabur/i.test(imgUrl);
                        const isHighRes = !/thumb|icon|square|tiny/i.test(imgUrl);

                        if (isCommercial || isHighRes) {
                            this.imageCache[cacheKey] = imgUrl;
                            return imgUrl;
                        }
                    }
                }
            } catch (e) { }
        }

        // 2. STRATEGY B: CATEGORY-SPECIFIC DATABASE SEARCH
        if (cat) {
            const apiMap = {
                'food': 'https://world.openfoodfacts.org',
                'grocery': 'https://world.openfoodfacts.org',
                'beauty': 'https://world.openbeautyfacts.org',
                'medicine': 'https://world.openproductsfacts.org',
                'ayurvedic': 'https://world.openproductsfacts.org'
            };

            const targetApi = apiMap[cat.toLowerCase()];
            if (targetApi) {
                try {
                    const term = encodeURIComponent(`${b} ${n}`);
                    const response = await fetch(`${targetApi}/cgi/search.pl?search_terms=${term}&search_simple=1&action=process&json=1`);
                    const data = await response.json();
                    if (data.products && data.products.length > 0) {
                        const best = data.products.find(p => p.image_front_url || p.image_url);
                        if (best) {
                            this.imageCache[cacheKey] = best.image_front_url || best.image_url;
                            return this.imageCache[cacheKey];
                        }
                    }
                } catch (e) { }
            }
        }

        // 3. STRATEGY C: DUCKDUCKGO INSTANT VERIFIED KNOWLEDGE
        try {
            const ddgQuery = encodeURIComponent(`${b} ${n}`);
            const ddgResponse = await fetch(`https://api.duckduckgo.com/?q=${ddgQuery}&format=json&no_html=1`);
            const ddgData = await ddgResponse.json();
            if (ddgData.Image) {
                const url = ddgData.Image.startsWith('http') ? ddgData.Image : `https://duckduckgo.com${ddgData.Image}`;
                this.imageCache[cacheKey] = url;
